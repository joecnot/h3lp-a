gunicorn app:app
pip install -r requirements.txt
gunicorn app:app
pip install -r requirements.txt
from flask import Flask, render_template, request, redirect, url_for, jsonify, g, abort
import sqlite3
from datetime import datetime
import os
import html

DB_PATH = 'helpabrother.db'
app = Flask(__name__)
app.config['SECRET_KEY'] = 'change-me-to-something-secret'

def get_db():
db = getattr(g, '_database', None)
if db is None:
create = not os.path.exists(DB_PATH)
db = g._database = sqlite3.connect(DB_PATH, check_same_thread=False)
db.row_factory = sqlite3.Row
if create:
init_db(db)
return db

def init_db(db):
cur = db.cursor()
cur.execute("""
CREATE TABLE posts (
id INTEGER PRIMARY KEY AUTOINCREMENT,
name TEXT,
title TEXT NOT NULL,
body TEXT NOT NULL,
created_at TEXT NOT NULL
);
""")
cur.execute("""
CREATE TABLE replies (
id INTEGER PRIMARY KEY AUTOINCREMENT,
post_id INTEGER NOT NULL,
name TEXT,
body TEXT NOT NULL,
upvotes INTEGER DEFAULT 0,
reported INTEGER DEFAULT 0,
created_at TEXT NOT NULL,
FOREIGN KEY(post_id) REFERENCES posts(id) ON DELETE CASCADE
);
""")
db.commit()

@app.teardown_appcontext
def close_connection(exception):
db = getattr(g, '_database', None)
if db is not None:
db.close()

# --- Helpers ---
def sanitize(s):
# very simple sanitation. Use more robust libraries for production.
return html.escape(s)

# --- Routes ---
@app.route('/')
def index():
db = get_db()
cur = db.execute("SELECT id, name, title, body, created_at FROM posts ORDER BY created_at DESC LIMIT 200")
posts = cur.fetchall()
return render_template('index.html', posts=posts)

@app.route('/post/<int:post_id>')
def view_post(post_id):
db = get_db()
cur = db.execute("SELECT * FROM posts WHERE id = ?", (post_id,))
post = cur.fetchone()
if not post:
abort(404)
cur = db.execute("SELECT * FROM replies WHERE post_id = ? ORDER BY upvotes DESC, created_at ASC", (post_id,))
replies = cur.fetchall()
return render_template('post.html', post=post, replies=replies)

@app.route('/create_post', methods=['POST'])
def create_post():
name = request.form.get('name', '').strip()
title = request.form.get('title', '').strip()
body = request.form.get('body', '').strip()
if not title or not body:
return "Title and body required", 400
db = get_db()
db.execute(
"INSERT INTO posts (name, title, body, created_at) VALUES (?, ?, ?, ?)",
(sanitize(name) or None, sanitize(title), sanitize(body), datetime.utcnow().isoformat())
)
db.commit()
return redirect(url_for('index'))

@app.route('/post/<int:post_id>/reply', methods=['POST'])
def reply(post_id):
name = request.form.get('name', '').strip()
body = request.form.get('body', '').strip()
if not body:
return "Reply body required", 400
db = get_db()
db.execute(
"INSERT INTO replies (post_id, name, body, upvotes, reported, created_at) VALUES (?, ?, ?, 0, 0, ?)",
(post_id, sanitize(name) or None, sanitize(body), datetime.utcnow().isoformat())
)
db.commit()
return redirect(url_for('view_post', post_id=post_id))

# Simple JSON API endpoints
@app.route('/api/reply/<int:reply_id>/upvote', methods=['POST'])
def api_upvote(reply_id):
db = get_db()
cur = db.execute("SELECT id FROM replies WHERE id = ?", (reply_id,))
if not cur.fetchone():
return jsonify({"error":"not found"}), 404
db.execute("UPDATE replies SET upvotes = upvotes + 1 WHERE id = ?", (reply_id,))
db.commit()
cur = db.execute("SELECT upvotes FROM replies WHERE id = ?", (reply_id,))
upvotes = cur.fetchone()['upvotes']
return jsonify({"upvotes": upvotes})

@app.route('/api/reply/<int:reply_id>/report', methods=['POST'])
def api_report(reply_id):
db = get_db()
cur = db.execute("SELECT id FROM replies WHERE id = ?", (reply_id,))
if not cur.fetchone():
return jsonify({"error":"not found"}), 404
db.execute("UPDATE replies SET reported = 1 WHERE id = ?", (reply_id,))
db.commit()
return jsonify({"reported": True})

# Basic admin: list reported replies (no auth in starter â€” add auth before deploying)
@app.route('/admin/reported')
def admin_reported():
db = get_db()
cur = db.execute("SELECT r.*, p.title as post_title FROM replies r JOIN posts p ON r.post_id = p.id WHERE r.reported = 1 ORDER BY r.created_at DESC")
rows = cur.fetchall()
return render_template('admin_reported.html', rows=rows)

if __name__ == '__main__':
# create DB if missing
get_db()
app.run(debug=True, host='127.0.0.1', port=5000)
